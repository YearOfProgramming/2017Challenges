The important thing to know here is that we start with an ordered list, we square everything (so we know have a list of all positive numbers or 0 if a 0 is included). This list is *partially* sorted. The half of the list that was originally negative is now in relative sorted order and the half of the list that was previously positive is also in relatively sorted order. So we have two parts of a list that are relatively sorted, and we want to sort it into one totally sorted list in linear time. Sounds a lot like merge from mergesort right? Bingo. That's what we are gonna do. To do this, we need to know how to find the originally negative half and the originally positive half. We can Go through the orignal list and find the first element that is 0 or positive, and set our first relatively sorted list to be ```orignal_list[0:this_element]``` (note: this will be sorted in decreasing order though since say -4 is more negative and therefore smaller than -2 but (-4)**2= 16 and (-2)**2=4 so this list will need to be reversed once the elements are squared) and then the second relatively sorted list is ```orignal_list[this_element:]``` then we go through and sqaure each element of the lists, and then just write a standard merge function and feed these two lists in as input. Merge takes linear time since we only ever touch an element of the orignal list a linear number of times: we do a comparison and then we either pop it off the smaller list and add it to the result list or we add it on after the while loop has finished. Also squaring all the elements is linear time, and breaking the list into the two halves is also linear time. All together, we have a linear time algorithm. 